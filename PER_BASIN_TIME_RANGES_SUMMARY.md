# Multi-Task LSTM 每个流域的独立时间划分

**生成时间**: 2025-12-27 17:03:23

## 重要发现

你的观察是**完全正确的**！代码确实为**每个流域独立划分时间**，而不是所有流域使用统一的时间范围。

## 时间划分机制

### 代码逻辑

在 `multi_task_lstm.py` 的 `_create_lookup_table` 方法中（第537-656行）：

```python
def _create_lookup_table(self):
    """
    为每个流域独立构建滑窗索引，并按该流域自身完整时间范围做比例切分。
    """
    for basin in tqdm(self.basins, ...):
        # 1. 找出该流域flow和waterlevel都非NaN的有效时间
        valid_forcing_times = [...]  # 筛选出有效时间点
        
        # 2. 确定该流域的有效时间起止
        first_valid_time = valid_forcing_times[0]
        last_valid_time = valid_forcing_times[-1]
        
        # 3. 按比例划分 (60% / 20% / 20%)
        train_end_idx = start_idx + int(total_span * TRAIN_RATIO)
        valid_end_idx = start_idx + int(total_span * (TRAIN_RATIO + VALID_RATIO))
```

**关键点**：
- 每个流域使用自己的 `first_valid_time` 和 `last_valid_time`
- 然后按比例 (60%/20%/20%) 划分为训练/验证/测试集
- 不同流域的数据可用性不同，因此时间范围也不同

## 实际数据统计

### 总体情况
- **流域总数**: 100个
- **成功提取**: 100个

### 时间范围差异

根据提取的数据，不同流域的时间范围差异很大：

| 流域ID | 训练集开始 | 训练集结束 | 测试集开始 | 测试集结束 | 数据跨度（年） |
|--------|------------|------------|------------|------------|----------------|
| 01017000 | 2007-09-18 | 2018-01-05 | 2021-06-12 | 2024-11-17 | ~17年 |
| 01017060 | 2008-11-18 | 2018-07-03 | 2021-09-16 | 2024-11-30 | ~16年 |
| 01018000 | 2007-09-18 | 2012-07-07 | 2014-02-11 | 2015-09-18 | ~8年 |
| 01021200 | 2007-09-21 | 2010-09-20 | 2011-09-19 | 2012-09-18 | ~5年 |

**差异原因**：
1. 不同流域的数据记录开始时间不同
2. 数据连续性不同（有些流域有间断）
3. 数据质量要求（同时有有效的径流和水位数据）

### 示例：流域 01017000

```
完整有效范围: 2007-09-18 21:00:00 至 2024-11-17 12:00:00
总有效步数: 32,148 步 (3小时分辨率)

训练集 (60%):
  时间: 2007-09-18 21:00:00 至 2018-01-05 15:00:00
  步数: 30,094 步

验证集 (20%):
  时间: 2018-01-05 18:00:00 至 2021-06-12 12:00:00
  步数: 10,031 步

测试集 (20%):
  时间: 2021-06-12 15:00:00 至 2024-11-17 12:00:00
  步数: 10,032 步
```

## 为什么采用这种设计？

### 优点

1. **适应数据可用性**
   - 不同流域的监测历史长短不同
   - 可以充分利用每个流域的所有可用数据

2. **公平性**
   - 每个流域都有相同比例的训练/验证/测试数据
   - 不会因为统一时间范围导致某些流域数据量过少

3. **灵活性**
   - 可以处理数据记录时间不一致的情况
   - 自动跳过NaN值，只使用真实观测数据

### 潜在问题

1. **时间一致性**
   - 不同流域的测试集可能代表不同的时间段
   - 可能影响跨流域的模型性能比较

2. **泛化能力评估**
   - 如果要评估模型在特定未来时间段的表现，需要注意不同流域的测试期不同

## 生成的文件

### 1. `runtime_basin_time_ranges.csv`
完整的流域时间划分表（所有字段）

**列**：
- `basin_id`: 流域ID
- `status`: 提取状态（success/no_valid_data/insufficient_data/error）
- `first_valid_time`, `last_valid_time`: 有效数据的起止时间
- `total_valid_steps`, `total_span_steps`: 有效步数统计
- `train_start`, `train_end`, `train_steps`: 训练集信息
- `valid_start`, `valid_end`, `valid_steps`: 验证集信息
- `test_start`, `test_end`, `test_steps`: 测试集信息

### 2. `runtime_basin_time_ranges_simple.csv`
简化版本（仅包含时间范围）

**列**：
- `basin_id`
- `train_start`, `train_end`
- `valid_start`, `valid_end`
- `test_start`, `test_end`

### 3. `runtime_basin_time_ranges_report.txt`
详细的文本格式报告，包含每个流域的完整时间划分信息

## 使用建议

### 1. 获取USGS Qualifiers时

由于每个流域的时间范围不同，建议：

**选项A**: 使用每个流域自己的时间范围
```python
import pandas as pd

df = pd.read_csv('runtime_basin_time_ranges_simple.csv')

for _, row in df.iterrows():
    basin_id = row['basin_id']
    train_start = row['train_start'][:10]  # 提取日期部分
    train_end = row['train_end'][:10]
    
    # 为该流域获取qualifiers
    # ...
```

**选项B**: 使用所有流域的共同时间范围（交集）
```python
# 找出所有流域训练集的最晚开始时间和最早结束时间
common_train_start = df['train_start'].max()
common_train_end = df['train_end'].min()
```

### 2. 模型评估时

注意：
- 不同流域的测试集代表不同的时间段
- 在比较流域间性能时，考虑时间因素的影响
- 如需统一测试期，可能需要重新划分数据

### 3. 结果解释时

在论文或报告中说明：
- 采用了"按流域独立划分"策略
- 每个流域按60/20/20比例划分
- 不同流域的绝对时间段可能不同

## 与之前提取的配置的关系

之前提取的 `runtime_time_config.txt` 显示的是：
```
训练集: 1980-01-01 至 2006-12-31
验证集: 2006-12-31 至 2015-12-31
测试集: 2015-12-31 至 2024-12-31
```

这是**理论上的全局划分**，基于CAMELSH数据集的完整时间范围（1980-2024）。

但**实际运行时**，每个流域使用的是其自己的有效数据时间范围，因此：
- 实际训练集通常在 2007-2008 开始（因为有效数据从那时开始）
- 实际测试集通常在 2021-2024 之间（根据各流域数据可用性）

## 总结

✅ **你的理解是正确的**：代码确实为每个流域独立划分时间

✅ **已成功提取**：所有100个流域的实际时间划分

✅ **关键发现**：不同流域的时间范围差异很大，从5年到17年不等

✅ **建议**：在使用这些时间配置时，需要根据具体需求选择是使用每个流域独立的时间范围，还是找出共同的时间范围

---

**相关文件**：
- `extract_per_basin_config.py`: 提取脚本
- `runtime_basin_time_ranges.csv`: 完整数据
- `runtime_basin_time_ranges_simple.csv`: 简化版本
- `runtime_basin_time_ranges_report.txt`: 详细报告

